"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var nekos_best_js_exports = {};
__export(nekos_best_js_exports, {
  Client: () => Client,
  default: () => nekos_best_js_default,
  fetchRandom: () => fetchRandom
});
module.exports = __toCommonJS(nekos_best_js_exports);
const fetch = (url, init) => import("node-fetch").then(({ default: fetch2 }) => fetch2(url, init));
const IMAGE_CATEGORIES = ["kitsune", "neko", "husbando", "waifu"];
const GIF_CATEGORIES = [
  "baka",
  "bite",
  "blush",
  "bored",
  "cry",
  "cuddle",
  "dance",
  "facepalm",
  "feed",
  "happy",
  "highfive",
  "hug",
  "kiss",
  "laugh",
  "pat",
  "pout",
  "shrug",
  "slap",
  "sleep",
  "smile",
  "smug",
  "stare",
  "think",
  "thumbsup",
  "tickle",
  "wave",
  "wink",
  "kick",
  "handhold",
  "punch",
  "shoot",
  "yeet",
  "poke",
  "nod",
  "nom",
  "nope",
  "handshake",
  "lurk",
  "peck",
  "yawn"
];
async function fetchRandom(category) {
  return new Client().fetch(category, 1);
}
class Client {
  #ratelimitData = null;
  #clientOptions;
  constructor(clientOptions) {
    this.#clientOptions = {
      ratelimitHandleMode: "sleep",
      ...clientOptions
    };
  }
  /**
   * Fetch and download a random file with its metadata (if available).
   * For more advanced options, you should use the `Client.fetch()` method and
   * fetch the file by yourself.
   *
   * Refer to the documentation for more details: https://docs.nekos.best/api/endpoints.html#get-categoryfilenameformat
   *
   * @param category The category to download from.
   */
  async fetchFile(category = null) {
    const fileDetails = (await this.fetch(category, 1)).results[0];
    const file = await fetchPath(void 0, fileDetails.url);
    return {
      ...fileDetails,
      data: Buffer.from(await file.arrayBuffer())
    };
  }
  /**
   * Fetch multiple assets with their metadata (if available).
   *
   * Refer to the documentation for more details: https://docs.nekos.best/api/endpoints.html#get-categoryamountx
   *
   * @param category Category of assets. Set to `null` to pick a random category.
   * @param amount The amount of assets. Refer to the documentation for the limits.
   */
  async fetch(category = null, amount) {
    if (!category) {
      category = pickRandomCategory();
    } else {
      validateCategory(category);
    }
    if (!Number.isSafeInteger(amount)) {
      throw new TypeError(`Expected a safe integer for amount. Got "${amount}".`);
    }
    return fetchJson(`${category}?amount=${amount}`);
  }
  /**
   * Search for assets.
   *
   * Refer to the documentation for more details: https://docs.nekos.best/api/endpoints.html#get-searchqueryxtypexcategoryxamountx
   *
   * @param query Search query.
   * @param category Category of assets. Set to `null` to pick a random category.
   * @param amount The amount of assets. Refer to the documentation for the limits.
   */
  async search(query, category = null, amount = 1) {
    if (this.#ratelimitData != null) {
      await handleRatelimit(this.#clientOptions.ratelimitHandleMode, this.#ratelimitData);
    }
    if (!category) {
      category = pickRandomCategory();
    } else {
      validateCategory(category);
    }
    if (!Number.isSafeInteger(amount)) {
      throw new TypeError(`Expected a safe integer for amount. Got "${amount}".`);
    }
    const type = 2 - +IMAGE_CATEGORIES.includes(category);
    const response = await fetchPath(`search?query=${encodeURIComponent(query)}&type=${type}&category=${category}&amount=${amount}`);
    const remaining = response.headers.get("x-rate-limit-remaining");
    const resetsIn = response.headers.get("x-rate-limit-reset");
    if (remaining != null && resetsIn != null) {
      this.#ratelimitData = {
        resetsIn: Date.parse(resetsIn),
        remaining: Number(remaining)
      };
    }
    return await response.json();
  }
}
async function fetchPath(path, fullUrl = null) {
  const url = fullUrl || `https://nekos.best/api/v2/${path}`;
  const response = await fetch(url, {
    headers: { "User-Agent": "nekos-best.js / 6.0.0" },
    redirect: "follow"
  });
  if (!response.ok) {
    const text = await response.text();
    throw new Error(`Failed to fetch url "${url}" (status code ${response.status}): ${text}`);
  }
  return response;
}
var nekos_best_js_default = Client;
async function fetchJson(path) {
  return await (await fetchPath(path)).json();
}
function validateCategory(category) {
  if (!(IMAGE_CATEGORIES.includes(category) || GIF_CATEGORIES.includes(category))) {
    throw new TypeError(`"${category}" is not a valid category. Available categories: ${IMAGE_CATEGORIES.join(", ")}, ${GIF_CATEGORIES.join(", ")}`);
  }
}
function pickRandomCategory() {
  const idx = Math.random() * (GIF_CATEGORIES.length + IMAGE_CATEGORIES.length) | 0;
  if (idx < IMAGE_CATEGORIES.length) {
    return IMAGE_CATEGORIES[idx];
  }
  return GIF_CATEGORIES[idx - IMAGE_CATEGORIES.length];
}
async function handleRatelimit(mode, data) {
  const now = Date.now();
  if (data.remaining <= 0 && data.resetsIn > now) {
    switch (mode) {
      case "sleep":
        await new Promise((resolve) => setTimeout(resolve, data.resetsIn - now));
        return;
      case "throw":
        throw Error("You are being ratelimited");
    }
  }
  --data.remaining;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Client,
  fetchRandom
});
